<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minerva 3D Orbital UI - Simple Test</title>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #0a0e17;
            color: #e6e6e6;
            font-family: sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Load Three.js -->
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Basic Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e17);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);
        
        const hemisphereLight = new THREE.HemisphereLight(0x4a6bdf, 0x080820, 0.3);
        scene.add(hemisphereLight);
        
        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.enableRotate = true;
        controls.minDistance = 5;
        controls.maxDistance = 25;
        controls.dampingFactor = 0.1;
        controls.rotateSpeed = 0.5;
        controls.update();
        
        // Create a starry background
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 100;
                positions[i + 2] = (Math.random() - 0.5) * 100;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        createStars();
        
        // Create Orb function (reusable)
        function createOrb(position, color, scale, isPulsing = false) {
            const orbGroup = new THREE.Group();
            orbGroup.position.set(position.x, position.y, position.z);
            
            // Main sphere
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                roughness: 0.2
            });
            
            const orb = new THREE.Mesh(geometry, material);
            orb.scale.set(scale.x, scale.y, scale.z);
            orbGroup.add(orb);
            
            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.15,
                roughness: 1
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.scale.set(scale.x * 1.2, scale.y * 1.2, scale.z * 1.2);
            orbGroup.add(glow);
            
            // Add subtle light to the orb for better visibility
            const orbLight = new THREE.PointLight(color, 0.5, 3);
            orbGroup.add(orbLight);
            
            // Store pulsing state
            orbGroup.userData = { 
                isPulsing,
                originalScale: { x: scale.x, y: scale.y, z: scale.z },
                rotationSpeed: 0.005,
                material: material
            };
            
            return orbGroup;
        }
        
        // Create agent orb
        function createAgentOrb(parentPosition, color, radius, speed) {
            const orb = createOrb(
                { x: parentPosition.x, y: parentPosition.y, z: parentPosition.z }, 
                color, 
                { x: 0.5, y: 0.5, z: 0.5 }
            );
            
            // Store orbital properties
            orb.userData.isAgent = true;
            orb.userData.orbit = {
                parent: parentPosition,
                radius: radius,
                speed: speed,
                angle: Math.random() * Math.PI * 2
            };
            
            return orb;
        }
        
        // Create project orb with agents
        function createProjectOrb(position, color, agentColors, name) {
            const projectOrb = createOrb(
                position, 
                color, 
                { x: 1.5, y: 1.5, z: 1.5 },
                false // Not pulsing by default
            );
            
            projectOrb.userData.isProject = true;
            projectOrb.userData.name = name;
            projectOrb.userData.active = false;
            projectOrb.userData.agents = [];
            
            // Create agent orbs (initially not visible)
            agentColors.forEach((agentColor, i) => {
                const baseSpeed = 0.01;
                const speedVariation = 0.005;
                const radius = 2 + i * 0.5;
                
                const agentOrb = createAgentOrb(
                    position, 
                    agentColor, 
                    radius, 
                    baseSpeed + speedVariation * i
                );
                
                agentOrb.visible = false; // Initially invisible
                scene.add(agentOrb);
                projectOrb.userData.agents.push(agentOrb);
            });
            
            return projectOrb;
        }
        
        // Create Minerva orb
        const minervaOrb = createOrb(
            { x: 0, y: 0, z: 0 }, 
            0x6f42c1, // Purple
            { x: 2.5, y: 2.5, z: 2.5 },
            true // Pulsing enabled
        );
        scene.add(minervaOrb);
        
        // Create project orbs
        const projectData = [
            { 
                position: { x: 3, y: 1, z: 0 }, 
                color: 0x4a6bdf, // Blue
                name: "GPT-4 Turbo",
                agents: [0xdc3545, 0x28a745, 0xffc107] // Red, Green, Yellow
            },
            { 
                position: { x: -3, y: -1, z: 0 }, 
                color: 0x28a745, // Green
                name: "Claude 3 Opus",
                agents: [0xfd7e14, 0x6f42c1] // Orange, Purple
            },
            { 
                position: { x: 0, y: 3, z: 0 }, 
                color: 0x6f42c1, // Purple
                name: "Mistral Large",
                agents: [0x17a2b8, 0xdc3545, 0xffc107] // Cyan, Red, Yellow
            },
            { 
                position: { x: -2, y: -2, z: 3 }, 
                color: 0xfd7e14, // Orange
                name: "Gemini Pro",
                agents: [0x17a2b8, 0x20c997] // Cyan, Teal
            }
        ];
        
        const projectOrbs = [];
        
        projectData.forEach(project => {
            const projectOrb = createProjectOrb(
                project.position,
                project.color,
                project.agents,
                project.name
            );
            scene.add(projectOrb);
            projectOrbs.push(projectOrb);
        });
        
        // Handle raycasting for click interactions
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            // Find intersections
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Find the first intersected orb
            for (let i = 0; i < intersects.length; i++) {
                // Find the Group that is a parent of the intersected object
                let currentObj = intersects[i].object;
                while (currentObj && currentObj.parent !== scene) {
                    currentObj = currentObj.parent;
                }
                
                // If no parent group was found or it's not a project orb, skip
                if (!currentObj || !currentObj.userData.isProject) continue;
                
                // Toggle project state
                const isProjectActive = !currentObj.userData.active;
                currentObj.userData.active = isProjectActive;
                currentObj.userData.isPulsing = isProjectActive;
                
                // Toggle agent visibility
                currentObj.userData.agents.forEach(agent => {
                    agent.visible = isProjectActive;
                });
                
                console.log(`${currentObj.userData.name} ${isProjectActive ? 'activated' : 'deactivated'}`);
                break;
            }
        }
        
        window.addEventListener('click', onMouseClick, false);
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update orb rotations
            scene.traverse(object => {
                if (object.userData && object.userData.rotationSpeed) {
                    object.rotation.y += object.userData.rotationSpeed;
                }
                
                // Update pulsating objects
                if (object.userData && object.userData.isPulsing) {
                    const time = Date.now() * 0.001; // Convert to seconds
                    const pulse = Math.sin(time * 2) * 0.05 + 1;
                    const originalScale = object.userData.originalScale;
                    
                    object.scale.set(
                        originalScale.x * pulse,
                        originalScale.y * pulse,
                        originalScale.z * pulse
                    );
                }
                
                // Update agent orbs orbiting
                if (object.userData && object.userData.isAgent && object.visible) {
                    const orbit = object.userData.orbit;
                    orbit.angle += orbit.speed;
                    
                    // Update position in circular orbit (lateral plane)
                    object.position.x = orbit.parent.x + orbit.radius * Math.cos(orbit.angle);
                    object.position.y = orbit.parent.y; // Keep same Y as parent
                    object.position.z = orbit.parent.z + orbit.radius * Math.sin(orbit.angle);
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
