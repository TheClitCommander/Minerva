<!DOCTYPE html>
<html>
<head>
    <title>Minerva Space UI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            color: #e2e8f0;
            background-color: #000;
            height: 100vh;
            width: 100vw;
            position: relative;
        }
        
        /* Space Universe Container - Zoomable */
        #universe-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            transition: transform 0.5s ease;
            transform-origin: center;
        }
        
        /* Deep Space Background */
        .space-background {
            position: absolute;
            width: 5000px; /* Large background for zooming */
            height: 5000px;
            left: -2000px;
            top: -2000px;
            background: url('https://images.unsplash.com/photo-1462331940025-496dfbfc7564?q=80&w=3000') center center / cover no-repeat;
            z-index: 0;
        }
        
        /* Minerva Orb (Central AI Hub) */
        .minerva-orb {
            position: absolute;
            width: 120px;
            height: 120px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(88,101,242,0.9) 0%, rgba(56,65,153,0.8) 75%, rgba(30,34,79,0.7) 100%);
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(88,101,242,0.6), 0 0 60px rgba(88,101,242,0.4), 0 0 90px rgba(88,101,242,0.2);
            z-index: 100;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            transition: all 0.4s ease;
            animation: pulse 3s infinite;
        }
        
        .minerva-orb:hover {
            box-shadow: 0 0 40px rgba(88,101,242,0.8), 0 0 80px rgba(88,101,242,0.6), 0 0 120px rgba(88,101,242,0.4);
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 30px rgba(88,101,242,0.6), 0 0 60px rgba(88,101,242,0.2); }
            50% { box-shadow: 0 0 40px rgba(88,101,242,0.8), 0 0 80px rgba(88,101,242,0.4); }
            100% { box-shadow: 0 0 30px rgba(88,101,242,0.6), 0 0 60px rgba(88,101,242,0.2); }
        }
        
        /* Project Orbs */
        .project-orbs-container {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            z-index: 99;
            display: none;
        }
        
        .project-orb {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            transition: all 0.3s ease;
            opacity: 0;
            background: radial-gradient(circle, rgba(99,102,241,0.9) 0%, rgba(79,70,229,0.8) 100%);
            box-shadow: 0 0 20px rgba(99,102,241,0.6);
        }
        
        .project-orb:hover {
            transform: scale(1.1);
        }
        
        .project-orbs-container.active .project-orb {
            opacity: 1;
        }
        
        /* Memory Context Indicator */
        .memory-context {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px 20px;
            color: #e2e8f0;
            font-size: 14px;
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            opacity: 0;
        }
        
        .memory-context.active {
            opacity: 1;
        }
        
        .memory-context .memory-icon {
            font-size: 16px;
            color: #8B5CF6;
        }
        
        .memory-context .memory-count {
            background-color: #8B5CF6;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: 600;
        }
        
        /* Smart Suggestions */
        .smart-suggestions {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            max-width: 600px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .smart-suggestions.active {
            opacity: 1;
        }
        
        .suggestion-chip {
            background-color: rgba(17, 24, 39, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 8px 16px;
            color: #e2e8f0;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(88,101,242,0.2);
            white-space: nowrap;
        }
        
        .suggestion-chip:hover {
            background-color: rgba(37, 44, 59, 0.8);
            transform: translateY(-2px);
            border-color: rgba(88,101,242,0.4);
        }
        
        /* Stars Layer */
        .stars-layer {
            position: absolute;
            width: 4000px;
            height: 4000px;
            left: -1500px;
            top: -1500px;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, rgba(255, 255, 255, 0.8), rgba(0,0,0,0)),
                radial-gradient(2px 2px at 40px 70px, rgba(255, 255, 255, 0.9), rgba(0,0,0,0)),
                radial-gradient(1px 1px at 90px 40px, rgba(255, 255, 255, 0.6), rgba(0,0,0,0)),
                radial-gradient(3px 3px at 160px 120px, rgba(255, 255, 255, 0.8), rgba(0,0,0,0)),
                radial-gradient(2px 2px at 230px 180px, rgba(255, 255, 255, 0.7), rgba(0,0,0,0)),
                radial-gradient(4px 4px at 350px 280px, rgba(255, 255, 255, 0.9), rgba(0,0,0,0)),
                radial-gradient(2px 2px at 400px 400px, rgba(255, 255, 255, 0.8), rgba(0,0,0,0)),
                radial-gradient(3px 3px at 550px 150px, rgba(255, 255, 255, 0.7), rgba(0,0,0,0));
            background-repeat: repeat;
            background-size: 600px 600px;
            z-index: 1;
        }
        
        /* Nebula Effects */
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(40px);
            opacity: 0.4;
            z-index: 2;
        }
        
        .nebula-1 {
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(123, 31, 162, 0.5), rgba(32, 0, 44, 0));
            left: 20%;
            top: 30%;
            animation: nebula-pulse 15s infinite alternate;
        }
        
        .nebula-2 {
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, rgba(32, 156, 238, 0.3), rgba(0, 44, 60, 0));
            right: 25%;
            top: 20%;
            animation: nebula-pulse 20s infinite alternate-reverse;
        }
        
        .nebula-3 {
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(255, 87, 51, 0.3), rgba(60, 20, 0, 0));
            left: 35%;
            bottom: 10%;
            animation: nebula-pulse 18s infinite alternate;
        }
        
        @keyframes nebula-pulse {
            0% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.15); opacity: 0.5; }
            100% { transform: scale(1); opacity: 0.4; }
        }
        
        /* Minerva planet styling */
        .minerva-planet {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            background: url('static/images/minerva_planet.jpg') no-repeat center center;
            background-size: contain;
            border-radius: 50%;
            box-shadow: 0 0 80px rgba(123, 31, 162, 0.6);
            z-index: 10;
            animation: planet-rotation 180s linear infinite;
        }
        
        @keyframes planet-rotation {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* Zoom Controls */
        .zoom-controls {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background-color: rgba(30, 41, 59, 0.8);
            color: #e2e8f0;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }
        
        .zoom-btn:hover {
            background-color: rgba(56, 189, 248, 0.8);
        }
        
        .zoom-level {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(30, 41, 59, 0.8);
            color: #e2e8f0;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        /* Web Research Information Styling */
        .web-research-info {
            margin-top: 10px;
            border-top: 1px solid rgba(148, 163, 184, 0.3);
            padding-top: 8px;
        }
        
        .web-research-header {
            font-size: 0.85rem;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 5px;
        }
        
        .web-results-list {
            list-style-type: none;
            padding-left: 0;
            margin: 5px 0;
        }
        
        .web-results-list li {
            font-size: 0.8rem;
            margin-bottom: 4px;
        }
        
        .web-results-list a {
            color: #93c5fd;
            text-decoration: none;
        }
        
        .web-results-list a:hover {
            text-decoration: underline;
        }
        
        /* Model legend styling */
        .model-legend {
            display: flex;
            flex-direction: column;
            margin-top: 8px;
            font-size: 0.7rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
        }
        
        .color-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .model-name {
            flex: 1;
        }
        
        .percentage {
            font-weight: 600;
            width: 40px;
            text-align: right;
        }
        
        .background-container {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* Chat Interface Container */
        #chat-interface {
            position: fixed;
            bottom: 25px;
            right: 25px;
            width: 350px;
            height: 450px;
            background-color: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease-in-out;
            backdrop-filter: blur(10px);
            resize: none;
        }
        
        /* Minimized state */
        #chat-interface.minimized {
            height: 40px;
            overflow: hidden;
        }
        
        /* Chat controls and header */
        #chat-header {
            padding: 10px 15px;
            color: #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.8);
            border-bottom: 1px solid rgba(100, 116, 139, 0.3);
            cursor: move; /* Entire header is draggable */
            user-select: none;
        }
        
        #chat-title {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #e2e8f0;
        }
        
        #chat-controls {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        
        .chat-control-btn {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 14px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .chat-control-btn:hover {
            color: #e2e8f0;
            background-color: rgba(100, 116, 139, 0.2);
        }
        
        /* Chat messages container */
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            scroll-behavior: smooth;
            color: #e2e8f0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Chat input area */
        #chat-input-container {
            display: flex;
            padding: 12px;
            background-color: rgba(30, 41, 59, 0.5);
            border-top: 1px solid rgba(100, 116, 139, 0.3);
            gap: 8px;
        }
        
        #chat-input {
            flex: 1;
            min-height: 40px;
            max-height: 120px;
            padding: 10px 15px;
            border-radius: 20px;
            border: 1px solid rgba(100, 116, 139, 0.5);
            background-color: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            resize: none;
            overflow-y: auto;
            outline: none;
            transition: border-color 0.2s;
            font-family: inherit;
            font-size: 14px;
        }
        
        #chat-input:focus {
            border-color: #3b82f6;
        }
        
        #send-message {
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 0;
            font-size: 16px;
        }
        
        #send-message:hover {
            background-color: #2563eb;
        }
        
        /* Message styles */
        .user-message {
            background-color: rgba(59, 130, 246, 0.15);
            border-radius: 8px;
            padding: 10px 15px;
            margin: 12px 0;
            align-self: flex-end;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            display: flex;
            flex-direction: column;
            border-bottom-right-radius: 0;
        }
        
        .ai-message {
            background-color: rgba(30, 41, 59, 0.4);
            border-radius: 8px;
            padding: 12px 15px;
            margin: 12px 0;
            align-self: flex-start;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            border-bottom-left-radius: 0;
        }
        
        .message-content {
            margin-bottom: 5px;
        }
        
        .message-timestamp {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            align-self: flex-end;
            margin-top: 4px;
        }
        
        .system-message {
            color: #94a3b8;
            font-style: italic;
            text-align: center;
            margin: 8px 0;
            font-size: 12px;
        }
        
        /* Loading indicator */
        .loading-indicator {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(30, 41, 59, 0.4);
            border-radius: 8px;
            margin: 8px 0;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* Model metrics panel */
        #model-metrics-panel {
            position: fixed;
            top: 25px;
            right: 25px;
            width: 400px;
            background-color: rgba(15, 23, 42, 0.92);
            border: 1px solid rgba(100, 116, 139, 0.5);
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            padding: 15px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        #model-metrics-panel.hidden {
            opacity: 0;
            visibility: hidden;
            transform: translateY(-20px);
        }
        
        /* Simple chart */
        .simple-chart {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .chart-bar {
            height: 24px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
    </style>
    <!-- Minerva Chat Integration Files -->
    <link rel="stylesheet" href="/static/css/minerva-chat-styles.css">
    <script src="/static/js/minerva-chat.js" defer></script>
    <script src="/static/js/minerva-chat-integration.js" defer></script>
    
    <!-- Markdown Formatting Support -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <!-- Universe Container (Zoomable) -->
    <div id="universe-container">
        <div class="space-background"></div>
        <div class="stars-layer"></div>
        
        <!-- Nebula effects -->
        <div class="nebula nebula-1"></div>
        <div class="nebula nebula-2"></div>
        <div class="nebula nebula-3"></div>
        
        <!-- Minerva planet -->
        <div class="minerva-planet"></div>
        
        <!-- Minerva Orb (Central AI Hub) -->
        <div class="minerva-orb" id="minerva-orb">
            <i class="fas fa-brain"></i>
        </div>
        
        <!-- Project Quick-Start Orbs -->
        <div class="project-orbs-container" id="project-orbs-container">
            <!-- Project orbs will be dynamically added here -->
        </div>
        
        <!-- Memory Context Indicator -->
        <div class="memory-context" id="memory-context">
            <i class="fas fa-memory memory-icon"></i>
            <span>Conversation Memory Active</span>
            <span class="memory-count">0</span>
        </div>
        
        <!-- Smart Suggestions -->
        <div class="smart-suggestions" id="smart-suggestions">
            <!-- Suggestion chips will be dynamically added here -->
        </div>
    </div>
    
    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-in">+</button>
        <div class="zoom-level" id="zoom-level">1x</div>
        <button class="zoom-btn" id="zoom-out">-</button>
    </div>
    
    <!-- Chat Interface (Think Tank) -->
    <div id="chat-interface">
        <!-- Chat header with controls -->
        <div id="chat-header">
            <div id="chat-title">Minerva Space</div>
            <div id="chat-controls">
                <button class="chat-control-btn" id="minimize-chat" title="Minimize chat"><i class="fas fa-minus"></i></button>
                <button class="chat-control-btn" id="toggle-metrics" title="Show AI Insights"><i class="fas fa-brain"></i></button>
                <button class="chat-control-btn" id="project-button" title="Manage projects"><i class="fas fa-project-diagram"></i></button>
            </div>
        </div>
        
        <!-- Model metrics panel (initially hidden) -->
        <div id="model-metrics-panel" class="hidden">
            <div class="metrics-header">
                <h5>Think Tank AI Metrics</h5>
                <button id="close-metrics" class="close-button"><i class="fas fa-times"></i></button>
            </div>
            <div class="think-tank-metrics">
                <div class="metric-card">
                    <h6>Blending</h6>
                    <div class="metric-value" id="blending-percentage">85.2%</div>
                </div>
                <div class="metric-card">
                    <h6>Rank Accuracy</h6>
                    <div class="metric-value" id="rank-accuracy">92.5%</div>
                </div>
                <div class="metric-card">
                    <h6>Routing Efficiency</h6>
                    <div class="metric-value" id="routing-efficiency">88.7%</div>
                </div>
            </div>
            
            <!-- Model Usage Visualization -->
            <div class="model-visualization-section">
                <h6>Model Usage Distribution</h6>
                <div id="model-usage-chart" class="visualization-container"></div>
            </div>
        </div>
        
        <div id="chat-messages">
            <div class="system-message">Welcome to Minerva's Think Tank. How can I assist you today?</div>
        </div>
        <div id="chat-input-container">
            <textarea id="chat-input" placeholder="Ask Minerva anything..."></textarea>
            <button id="send-message"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <script>
        // Add a simple function to ensure chat messages can be sent
        function fixChatMessageSending() {
            console.log('Adding reliable chat message functionality');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-message');
            
            if (!chatInput || !sendButton) {
                console.error('Chat elements not found - will retry');
                setTimeout(fixChatMessageSending, 500);
                return;
            }
            
            console.log('Chat elements found - applying fix');
            
            // Visual indicator that our fix is active
            sendButton.style.boxShadow = '0 0 5px rgba(0, 120, 212, 0.7)';
            
            // Simple function to send a message
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;
                
                // Clear input immediately for better UX
                chatInput.value = '';
                
                console.log('Sending message:', message);
                
                // First try using the existing API function that maintains conversation memory
                if (typeof window.sendToChatAPI === 'function') {
                    window.sendToChatAPI(message);
                } else {
                    // Fallback to displaying a message locally
                    const chatMessages = document.getElementById('chat-messages');
                    if (chatMessages) {
                        // Display user message
                        const userMessage = document.createElement('div');
                        userMessage.className = 'user-message';
                        userMessage.textContent = message;
                        chatMessages.appendChild(userMessage);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // Display temporary AI response
                        const aiMessage = document.createElement('div');
                        aiMessage.className = 'ai-message';
                        aiMessage.textContent = 'Message received. API connection not available in test mode.';
                        chatMessages.appendChild(aiMessage);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }
            
            // Add event listeners
            chatInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            sendButton.addEventListener('click', sendMessage);
            
            console.log('Chat send functionality fixed and ready');
        }
        
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log(`Minerva Space UI initialized at ${new Date().toLocaleTimeString()}`);
            
            // Original initialization that must be kept
            initChatInterface();
            initZoomControls();
            
            // Add our chat fix with a slight delay to ensure DOM is ready
            setTimeout(fixChatMessageSending, 500);
        });
    
    

// Helper function for API requests
function sendAPIRequest(payload) {
    // Show typing indicator
    const chatMessages = document.getElementById('chat-messages');
    const loadingId = 'loading-' + Date.now();
    const loadingElement = document.createElement('div');
    loadingElement.id = loadingId;
    loadingElement.className = 'message ai-message loading';
    loadingElement.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
    chatMessages.appendChild(loadingElement);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Send to API
    fetch('/api/think-tank', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
    })
    .then(response => {
        if (!response.ok) throw new Error(`API error: ${response.status}`);
        return response.json();
    })
    .then(data => {
        // Remove loading indicator
        const loadingElement = document.getElementById(loadingId);
        if (loadingElement && chatMessages.contains(loadingElement)) {
            chatMessages.removeChild(loadingElement);
        }
        
        // Store conversation ID
        if (data.conversation_id) {
            localStorage.setItem('minerva_conversation_id', data.conversation_id);
        }
        
        // Add AI response
        addAIMessage(data.response, data.model_info?.models_used || ['Think Tank']);
    })
    .catch(error => {
        console.error('Error fetching response:', error);
        
        // Remove loading indicator
        const loadingElement = document.getElementById(loadingId);
        if (loadingElement && chatMessages.contains(loadingElement)) {
            chatMessages.removeChild(loadingElement);
        }
        
        // Add error message
        const errorElement = document.createElement('div');
        errorElement.className = 'message ai-message error';
        errorElement.textContent = 'Sorry, there was an error processing your request. Please try again.';
        chatMessages.appendChild(errorElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    });
}

// Define global sendMessageToAPI for external access
window.sendMessageToAPI = function(message) {
    console.log('Using global sendMessageToAPI wrapper');
    // Add user message to chat
    addUserMessage(message);
    
    // Prepare payload for API
    const payload = {
                        message: message,
                        session_id: sessionId || 'session-' + Date.now(),
                        user_id: userId || 'user-' + Date.now(),
                        store_in_memory: true,
                        include_model_info: true,
                        conversation_id: localStorage.getItem('minerva_conversation_id') || null
                    };
                    
                    // Use the API request function
                    sendAPIRequest(payload);
                };

            // Initialize other components if necessary
            if (typeof initOrbitalUI === 'function') {
                try {
                    initOrbitalUI();
                } catch (e) {
                    console.warn('Error initializing Orbital UI:', e);
                }
            }
                        const loadingElement = document.getElementById(loadingId);
                        if (loadingElement && chatMessages.contains(loadingElement)) {
                            chatMessages.removeChild(loadingElement);
                        }
                        addAIMessage('I apologize, but I encountered an error processing your request. Please try again.', ['System']);
                    });
                };
            }
            
            // Let's do direct console checks to debug elements
            console.log('DEBUG: Chat elements check');
            console.log('DEBUG: chat-input exists?', !!document.getElementById('chat-input'));
            console.log('DEBUG: send-message exists?', !!document.getElementById('send-message'));
            console.log('DEBUG: chat-messages exists?', !!document.getElementById('chat-messages'));
            
            // Direct event binding for chat elements
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-message');
            
            if (chatInput && sendButton) {
                console.log('DEBUG: Adding direct event listeners to chat elements');
                
                // Debug logging - direct DOM check
                console.log('DEBUG: chatInput ID:', chatInput.id);
                console.log('DEBUG: sendButton ID:', sendButton.id);
                console.log('DEBUG: chatInput HTML:', chatInput.outerHTML);
                console.log('DEBUG: sendButton HTML:', sendButton.outerHTML);
                
                // Force the elements to have specific IDs to match easily
                chatInput.id = 'debug-chat-input';
                sendButton.id = 'debug-send-button';
                
                // Test direct button functionality
                sendButton.innerHTML = 'Send Debug';
                sendButton.style.backgroundColor = 'red';
                
                // Remove any existing event listeners by replacing elements
                const newSendButton = sendButton.cloneNode(true);
                sendButton.parentNode.replaceChild(newSendButton, sendButton);
                
                // Add new click handler with debug output
                newSendButton.onclick = function() {
                    console.log('DEBUG: Send button clicked!');
                    const message = chatInput.value.trim();
                    console.log('DEBUG: Message to send:', message);
                    
                    // Log window functions
                    console.log('DEBUG: sendMessageToAPI exists?', typeof window.sendMessageToAPI === 'function');
                    console.log('DEBUG: sendToChatAPI exists?', typeof window.sendToChatAPI === 'function');
                    
                    if (message) {
                        alert('Sending message: ' + message); // Visual notification for testing
                        try {
                            console.log('DEBUG: Attempting to send message');
                            window.sendMessageToAPI(message);
                            console.log('DEBUG: Message sent successfully');
                        } catch(err) {
                            console.error('DEBUG: Error sending message:', err);
                            alert('Error sending: ' + err.message);
                        }
                        chatInput.value = '';
                    }
                };
                
                // Add direct global function for browser console testing
                window.testSendMessage = function(testMessage) {
                    console.log('DEBUG: Manual test function called');
                    try {
                        window.sendMessageToAPI(testMessage || 'Test message from console');
                        return 'Test message sent';
                    } catch(err) {
                        console.error('Error in test function:', err);
                        return 'Error: ' + err.message;
                    }
                };
                console.log('DEBUG: Added testSendMessage() function for manual testing - try running testSendMessage() in console');
                
                // Handle Enter key with debug output
                chatInput.onkeydown = function(e) {
                    console.log('DEBUG: Key pressed in chat input:', e.key);
                    if (e.key === 'Enter' && !e.shiftKey) {
                        console.log('DEBUG: Enter key detected!');
                        e.preventDefault();
                        const message = chatInput.value.trim();
                        console.log('DEBUG: Message from keydown:', message);
                        if (message) {
                            try {
                                window.sendMessageToAPI(message);
                                console.log('DEBUG: Message sent via Enter key');
                            } catch(err) {
                                console.error('DEBUG: Error sending message via Enter:', err);
                            }
                            chatInput.value = '';
                        }
                    }
                };
                
                // Log successful setup
                console.log('DEBUG: Event listeners successfully added');
                
            } else {
                console.error('DEBUG ERROR: Chat input or send button not found:', {
                    chatInput: chatInput ? chatInput.id : null,
                    sendButton: sendButton ? sendButton.id : null,
                    inputExists: !!chatInput,
                    buttonExists: !!sendButton,
                    docBody: document.body.innerHTML.substring(0, 500) + '...' // Show part of the body for debugging
                });
            }
        });
        
        // Initialize the chat interface
        function initChatInterface() {
            // Get DOM elements
            const chatInterface = document.getElementById('chat-interface');
            const chatHeader = document.getElementById('chat-header');
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-message');
            const minimizeBtn = document.getElementById('minimize-chat');
            const toggleMetricsBtn = document.getElementById('toggle-metrics');
            const metricsPanel = document.getElementById('model-metrics-panel');
            const closeMetricsBtn = document.getElementById('close-metrics');
            
            // Make chat interface draggable
            makeDraggable(chatInterface, chatHeader);
            
            // Set up minimize button
            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', function() {
                    chatInterface.classList.toggle('minimized');
                    const icon = this.querySelector('i');
                    if (icon) {
                        if (chatInterface.classList.contains('minimized')) {
                            icon.classList.remove('fa-minus');
                            icon.classList.add('fa-expand');
                            this.setAttribute('title', 'Expand chat');
                        } else {
                            icon.classList.remove('fa-expand');
                            icon.classList.add('fa-minus');
                            this.setAttribute('title', 'Minimize chat');
                        }
                    }
                });
            }
            
            // Set up metrics toggle and close buttons
            if (toggleMetricsBtn && metricsPanel) {
                toggleMetricsBtn.addEventListener('click', function() {
                    metricsPanel.classList.toggle('hidden');
                });
            }
            
            if (closeMetricsBtn && metricsPanel) {
                closeMetricsBtn.addEventListener('click', function() {
                    metricsPanel.classList.add('hidden');
                });
            }
            
            // Set up model usage chart
            setupModelUsageChart();
            
            // Set up chat input and send button
            if (sendButton && chatInput) {
                sendButton.addEventListener('click', sendMessage);
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }
            
            // Function to send a message
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;
                
                console.log('Sending message:', message);
                chatInput.value = '';
                
                // Hide suggestions when message is sent
                const suggestions = document.getElementById('smart-suggestions');
                if (suggestions) {
                    suggestions.classList.remove('active');
                }
                
                // Use sendToChatAPI if available, otherwise fallback to legacy flow
                if (typeof window.sendToChatAPI === 'function') {
                    console.log('Using enhanced sendToChatAPI function');
                    window.sendToChatAPI(message, {
                        conversation_id: localStorage.getItem('minerva_conversation_id') || null
                    });
                } else {
                    console.log('Falling back to legacy flow');
                    // Add user message to chat
                    addUserMessage(message);
                    
                    // Save chat history after adding user message
                    if (typeof saveChatHistory === 'function') {
                        saveChatHistory();
                    }
                    
                    // Get real AI response from Think Tank with memory integration
                    getAIResponse(message);
                }
            }
            
            // Function to add a user message to the chat
            function addUserMessage(message) {
                const msgElement = document.createElement('div');
                msgElement.className = 'user-message';
                msgElement.textContent = message;
                
                // Add message to chat
                chatMessages.appendChild(msgElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Function to add an AI message to the chat
            function addAIMessage(message, modelInfo = null, webResearchInfo = null) {
                const msgElement = document.createElement('div');
                msgElement.className = 'ai-message';
                
                // Create the main response container
                const responseContainer = document.createElement('div');
                responseContainer.className = 'response-content';
                responseContainer.innerHTML = message.replace(/\n/g, '<br>');
                msgElement.appendChild(responseContainer);
                
                // Add model info if provided
                if (modelInfo) {
                    const infoElement = document.createElement('div');
                    infoElement.className = 'model-info';
                    
                    // Store raw model info for saving to session storage
                    try {
                        if (typeof modelInfo === 'object') {
                            infoElement.setAttribute('data-model-info', JSON.stringify(modelInfo));
                        }
                    } catch (e) {
                        console.error('Error storing model info:', e);
                    }
                    
                    // Check if we have enhanced model_info object
                    if (typeof modelInfo === 'object' && !Array.isArray(modelInfo)) {
                        // Create detailed model info display
                        let modelHTML = '<div class="model-details">';
                        
                        // Show primary model
                        const primaryModel = modelInfo.primary_model || 'Think Tank';
                        modelHTML += `<div class="primary-model">Primary Model: <strong>${primaryModel}</strong></div>`;
                        
                        // Show model contributions if available - UPDATED FOR CONSOLIDATED THINK TANK
                        if (modelInfo.models_used && Array.isArray(modelInfo.models_used) && modelInfo.models_used.length > 0) {
                            modelHTML += '<div class="model-contributions">Models Used: ';
                            
                            // Handle both legacy and new consolidated format
                            if (typeof modelInfo.models_used[0] === 'string') {
                                // New consolidated format - array of strings
                                const colors = ['#3B82F6', '#10B981', '#8B5CF6', '#F59E0B', '#EC4899'];
                                modelInfo.models_used.forEach((model, index) => {
                                    const color = colors[index % colors.length];
                                    modelHTML += `<span class="model-badge" style="background-color: ${color}">${model}</span>`;
                                });
                            } else {
                                // Legacy format - array of objects
                                modelInfo.models_used.forEach((model, index) => {
                                    const modelName = model.name || 'Unknown';
                                    const contribution = model.contribution ? `${model.contribution}%` : '';
                                    const color = model.color || '#3B82F6';
                                    modelHTML += `<span class="model-badge" style="background-color: ${color}">${modelName} ${contribution}</span>`;
                                });
                            }
                            modelHTML += '</div>';
                        }
                        
                        // Show blending strategy if available - UPDATED FOR CONSOLIDATED THINK TANK
                        let blendingStrategy = null;
                        if (modelInfo.blending && modelInfo.blending.method) {
                            // New consolidated format
                            blendingStrategy = modelInfo.blending.method;
                        } else if (modelInfo.blending_info && modelInfo.blending_info.strategy_name) {
                            // Legacy format with blending_info
                            blendingStrategy = modelInfo.blending_info.strategy_name;
                        } else if (modelInfo.blending_strategy) {
                            // Legacy format with direct field
                            blendingStrategy = modelInfo.blending_strategy;
                        }
                        
                        if (blendingStrategy) {
                            // Clean up strategy name for display (remove "blend_" prefix, convert to title case)
                            const displayStrategy = blendingStrategy
                                .replace('blend_', '')
                                .replace(/_/g, ' ')
                                .replace(/\b\w/g, l => l.toUpperCase());
                            modelHTML += `<div class="blending-strategy">Blending Strategy: <strong>${displayStrategy}</strong></div>`;
                        }
                        
                        // Show contributing models if available (new consolidated format)
                        if (modelInfo.blending && modelInfo.blending.contributing_models && 
                            Array.isArray(modelInfo.blending.contributing_models) && 
                            modelInfo.blending.contributing_models.length > 0) {
                            
                            modelHTML += '<div class="contributing-models">Contributing Models: ';
                            const colors = ['#10B981', '#8B5CF6', '#F59E0B'];
                            modelInfo.blending.contributing_models.forEach((model, index) => {
                                const color = colors[index % colors.length];
                                modelHTML += `<span class="model-badge" style="background-color: ${color}">${model}</span>`;
                            });
                            modelHTML += '</div>';
                        }
                        
                        // Add rankings toggle and details if available
                        if (modelInfo.rankings && Array.isArray(modelInfo.rankings) && modelInfo.rankings.length > 0) {
                            modelHTML += `<button class="rankings-toggle" onclick="toggleModelRankings(this)">Show Model Rankings</button>`;
                            
                            modelHTML += `<div class="rankings-details" style="display: none;">`;
                            modelHTML += `<table class="rankings-table">`;
                            modelHTML += `<tr><th>Model</th><th>Score</th><th>Details</th></tr>`;
                            
                            modelInfo.rankings.forEach(rank => {
                                const modelName = rank.model || 'Unknown';
                                let scoreDisplay = '';
                                
                                // Handle both score formats (0-1 decimal or percentage)
                                if (rank.score !== undefined) {
                                    const scoreValue = rank.score;
                                    scoreDisplay = scoreValue > 1 ? scoreValue.toFixed(0) : (scoreValue * 100).toFixed(0) + '%';
                                } else {
                                    scoreDisplay = '-';
                                }
                                
                                // Get reasoning text
                                const reason = rank.reasoning || rank.reason || 'No reasoning provided';
                                
                                // Build details cell with both reasoning and detailed metrics
                                let detailsHTML = `<div class="reason">${reason}</div>`;
                                
                                // Add detailed scores if available (from consolidated Think Tank)
                                if (rank.quality_score || rank.capability_score || rank.confidence) {
                                    detailsHTML += `<div class="detailed-scores">`;
                                    
                                    const metrics = [];
                                    if (rank.quality_score !== undefined) {
                                        const quality = (rank.quality_score * 100).toFixed(0);
                                        metrics.push(`<span class="metric">Quality: <strong>${quality}%</strong></span>`);
                                    }
                                    
                                    if (rank.capability_score !== undefined) {
                                        const capability = (rank.capability_score * 100).toFixed(0);
                                        metrics.push(`<span class="metric">Capability: <strong>${capability}%</strong></span>`);
                                    }
                                    
                                    if (rank.confidence !== undefined) {
                                        const confidence = (rank.confidence * 100).toFixed(0);
                                        metrics.push(`<span class="metric">Confidence: <strong>${confidence}%</strong></span>`);
                                    }
                                    
                                    detailsHTML += metrics.join(' | ');
                                    detailsHTML += `</div>`;
                                }
                                
                                modelHTML += `<tr>`;
                                modelHTML += `<td>${modelName}</td><td>${scoreDisplay}</td><td>${detailsHTML}</td>`;
                                modelHTML += `</tr>`;
                            });
                            
                            modelHTML += `</table></div>`;
                        }
                        
                        modelHTML += '</div>';
                        infoElement.innerHTML = modelHTML;
                    } else {
                        // Fall back to simple model display for array or string
                        let modelText = '';
                        
                        if (Array.isArray(modelInfo)) {
                            // If we have multiple models, join them with commas
                            modelText = modelInfo.join(', ');
                        } else if (typeof modelInfo === 'string') {
                            // If it's a single string, use it directly
                            modelText = modelInfo;
                        } else {
                            // Default to Think Tank
                            modelText = 'Think Tank';
                        }
                        
                        const isMultiple = Array.isArray(modelInfo) && modelInfo.length > 1;
                        infoElement.innerHTML = `<small>Powered by ${isMultiple ? 'multiple AI models' : 'AI model'}: ${modelText}</small>`;
                    }
                    
                    msgElement.appendChild(infoElement);
                }
                
                // Add web research info if provided
                if (webResearchInfo) {
                    msgElement.appendChild(webResearchInfo);
                }
                
                chatMessages.appendChild(msgElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
            // Function to get a real AI response using the Think Tank processor with memory integration
            async function getAIResponse(userMessage) {
                // Create a unique ID for this loading indicator
                const loadingId = 'loading-' + Date.now();
                const loadingIndicator = document.createElement('div');
                loadingIndicator.id = loadingId;
                loadingIndicator.className = 'loading-indicator';
                loadingIndicator.innerHTML = 'Minerva is thinking...';
                chatMessages.appendChild(loadingIndicator);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Keep track of all existing messages for debugging
                console.log('Current message count before API call:', document.querySelectorAll('.user-message, .ai-message').length);
                
                try {
                    console.log('Processing user message:', userMessage);
                    
                    // Generate a conversation ID if needed
                    const conversationId = generateConversationId();
                    console.log('Using conversation ID:', conversationId);
                    
                    // Show memory context indicator when chat is active
                    const memoryContext = document.getElementById('memory-context');
                    memoryContext.classList.add('active');
                    
                    // Update memory count indicator
                    updateMemoryCount();
                    
                    let data;
                    
                    // Use the real Think Tank API with advanced features and memory integration
                    console.log('Sending request to Think Tank API with memory enhancement...');
                    const response = await fetch('/api/think-tank', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': conversationId
                        },
                        body: JSON.stringify({
                            message: userMessage,
                            conversation_id: conversationId,
                            use_memory: true,  // Enable memory integration
                            enhance_with_memory: true,  // Use memory to enhance responses
                            model_preferences: {
                                include_detailed_rankings: true,
                                include_model_contributions: true,
                                include_capability_scores: true,
                                include_blending_details: true,
                                blend_responses: true
                            }
                        })
                    });
                    
                    // Check if the response was successful
                    if (!response.ok) {
                        console.error(`API Error: ${response.status} - ${response.statusText}`);
                        throw new Error(`Think Tank API Error (${response.status})`);
                    }
                    
                    // Parse the response data
                    try {
                        data = await response.json();
                        console.log('API Response:', data);
                    } catch (parseError) {
                        console.error('Error parsing API response:', parseError);
                        throw new Error('Invalid response from Think Tank API');
                    }
                    
                    // Remove loading indicator by ID to ensure we remove the correct one
                    const loadingElement = document.getElementById(loadingId);
                    if (loadingElement && chatMessages.contains(loadingElement)) {
                        chatMessages.removeChild(loadingElement);
                    }
                    
                    // Extract model information based on the enhanced response structure
                    let modelInfo = [];
                    
                    try {
                        if (data.model_info) {
                            console.log('Model info available:', data.model_info);
                            if (data.model_info.models_used && Array.isArray(data.model_info.models_used)) {
                                // Extract just the names from the models_used array
                                modelInfo = data.model_info.models_used.map(model => model.name);
                                console.log('Extracted model names:', modelInfo);
                            } else if (data.model_info.primary_model) {
                                modelInfo = [data.model_info.primary_model];
                            } else if (data.model_info.rankings && Array.isArray(data.model_info.rankings) && data.model_info.rankings.length > 0) {
                                // Extract model names from rankings
                                modelInfo = data.model_info.rankings.map(item => item.model);
                            }
                        }
                    } catch (err) {
                        console.error('Error extracting model info:', err);
                    }
                    
                    // Default if no model information is available
                    if (!modelInfo || modelInfo.length === 0) {
                        modelInfo = ['Think Tank'];
                    }
                                       // Add web research information if available
                    if (data.web_research && data.web_research.results && data.web_research.results.length > 0) {
                        const webInfo = document.createElement('div');
                        webInfo.className = 'web-research-info';
                        webInfo.innerHTML = `<div class="web-research-header">Web Research Results:</div>`;
                        
                        const webList = document.createElement('ul');
                        webList.className = 'web-results-list';
                        
                        data.web_research.results.forEach(result => {
                            const webItem = document.createElement('li');
                            webItem.innerHTML = `<a href="${result.url}" target="_blank">${result.title}</a>`;
                            webList.appendChild(webItem);
                        });
                        
                        webInfo.appendChild(webList);
                        
                        // Log before adding AI message with web info
                        console.log('Adding AI message with web info, current count:', document.querySelectorAll('.user-message, .ai-message').length);
                        
                        // Add web info after normal response
                        addAIMessage(data.response, data.model_info, webInfo);
                    } else {
                        // Log before adding regular AI message
                        console.log('Adding regular AI message, current count:', document.querySelectorAll('.user-message, .ai-message').length);
                        
                        // Regular response without web results
                        addAIMessage(data.response, data.model_info);
                    }
                    
                    // Log after adding for debugging
                    console.log('After adding AI message, new count:', document.querySelectorAll('.user-message, .ai-message').length);
                    
                    // Update metrics based on enhanced model data
                    updateMetricsWithModelData(data.model_info);
                    
                    // Log detailed model rankings if available
                    if (data.model_info && data.model_info.ranked_responses) {
                        console.log('Model Rankings:', data.model_info.ranked_responses);
                    }
                } catch (error) {
                    console.error('Error fetching AI response:', error);
                    
                    // Remove loading indicator by ID
                    const loadingElement = document.getElementById(loadingId);
                    if (loadingElement && chatMessages.contains(loadingElement)) {
                        chatMessages.removeChild(loadingElement);
                    }
                    
                    // Use our proper error handler to get a standardized error response
                    const errorData = handleThinkTankError(error);
                    
                    // Extract model names for display
                    let modelNames = ['System'];
                    if (errorData.model_info && errorData.model_info.models_used) {
                        modelNames = errorData.model_info.models_used.map(model => model.name);
                    }
                    
                    // Display the error message to the user
                    addAIMessage(errorData.response, modelNames);
                    
                    // Log detailed error information for debugging
                    console.log('Error details:', errorData.error_details);
                }
            }
            
            // Generate a consistent conversation ID with persistence
            function generateConversationId() {
                // Try to get from localStorage first for persistence
                const storedId = localStorage.getItem('minerva_conversation_id');
                
                if (storedId) {
                    window.conversationId = storedId;
                    console.log('Using stored conversation ID:', storedId);
                } else if (!window.conversationId) {
                    // Create a new ID if none exists
                    window.conversationId = 'conv-' + Date.now() + '-' + Math.random().toString(36).substring(2, 10);
                    // Store for future sessions
                    localStorage.setItem('minerva_conversation_id', window.conversationId);
                    console.log('Created new conversation ID:', window.conversationId);
                }
                
                return window.conversationId;
            }
            
            // Simple welcome message function
            function addWelcomeMessage() {
                // Add welcome message
                const welcomeMsg = document.createElement('div');
                welcomeMsg.className = 'system-message';
                welcomeMsg.innerHTML = 'Welcome to Minerva\'s Think Tank. How can I assist you today?';
                chatMessages.appendChild(welcomeMsg);
            }
            
            // Save current chat to session storage
            function saveChatHistory() {
                const conversationId = generateConversationId();
                const messages = [];
                
                // Collect all messages from the DOM
                const messageElements = chatMessages.querySelectorAll('.user-message, .ai-message, .system-message');
                
                messageElements.forEach(element => {
                    if (element.classList.contains('user-message')) {
                        messages.push({
                            type: 'user',
                            content: element.querySelector('.message-content').textContent,
                            timestamp: element.getAttribute('data-timestamp') || new Date().toISOString()
                        });
                    } else if (element.classList.contains('ai-message')) {
                        // Extract model info if available
                        let modelInfo = null;
                        const modelInfoEl = element.querySelector('.model-info');
                        if (modelInfoEl && modelInfoEl.getAttribute('data-model-info')) {
                            try {
                                modelInfo = JSON.parse(modelInfoEl.getAttribute('data-model-info'));
                            } catch (e) {
                                console.error('Error parsing model info:', e);
                            }
                        }
                        
                        messages.push({
                            type: 'ai',
                            content: element.querySelector('.response-content').innerHTML,
                            modelInfo: modelInfo,
                            timestamp: element.getAttribute('data-timestamp') || new Date().toISOString()
                        });
                    } else if (element.classList.contains('system-message')) {
                        messages.push({
                            type: 'system',
                            content: element.innerHTML
                        });
                    }
                });
                
                // Save to session storage
                sessionStorage.setItem(`minerva_chat_${conversationId}`, JSON.stringify(messages));
                console.log(`Saved ${messages.length} messages to session storage`);
                
                // Update memory count
                updateMemoryCount();
            }
            
            // Get message count for memory indicator
            function getMessageCount() {
                const conversationId = generateConversationId();
                const savedMessages = sessionStorage.getItem(`minerva_chat_${conversationId}`);
                
                if (savedMessages) {
                    try {
                        const messages = JSON.parse(savedMessages);
                        return messages.filter(msg => msg.type === 'user' || msg.type === 'ai').length;
                    } catch (error) {
                        console.error('Error counting messages:', error);
                        return 0;
                    }
                }
                
                return 0;
            }
            
            // Update memory count indicator
            function updateMemoryCount() {
                const messageCount = getMessageCount();
                const memoryCount = document.querySelector('.memory-count');
                if (memoryCount) {
                    memoryCount.textContent = messageCount;
                }
                
                // Show or hide memory context indicator
                const memoryContext = document.getElementById('memory-context');
                if (memoryContext) {
                    if (messageCount > 0) {
                        memoryContext.classList.add('active');
                    } else {
                        memoryContext.classList.remove('active');
                    }
                }
            }
            
            // Update metrics based on enhanced model data
            function updateMetricsWithModelData(modelInfo) {
                // Extract metrics from model info if available
                let blendingScore = 0, rankAccuracy = 0, routingEfficiency = 0;
                
                if (modelInfo) {
                    // Use enhanced metrics structure if available
                    if (modelInfo.blending_strategy) {
                        // Use the response_quality if available
                        blendingScore = modelInfo.response_quality * 10 || 92;
                    } else {
                        blendingScore = Math.random() * 10 + 85;
                    }
                    
                    // Extract ranking accuracy from rankings if available
                    if (modelInfo.rankings && modelInfo.rankings.length > 0) {
                        // Calculate average confidence from rankings
                        const totalScores = modelInfo.rankings.reduce((sum, item) => sum + (item.score || 0), 0);
                        const maxPossibleScore = modelInfo.rankings.length * 10; // Assuming scores are 0-10
                        rankAccuracy = (totalScores / maxPossibleScore) * 100;
                    } else if (modelInfo.ranking_quality) {
                        rankAccuracy = modelInfo.ranking_quality;
                    } else {
                        rankAccuracy = Math.random() * 10 + 85;
                    }
                    
                    // Extract routing efficiency
                    if (modelInfo.query_analysis && modelInfo.query_analysis.confidence) {
                        routingEfficiency = modelInfo.query_analysis.confidence * 100;
                    } else if (modelInfo.routing_efficiency) {
                        routingEfficiency = modelInfo.routing_efficiency;
                    } else {
                        routingEfficiency = Math.random() * 10 + 85;
                    }
                    
                    // Ensure values are within reasonable range
                    blendingScore = Math.min(100, Math.max(70, blendingScore));
                    rankAccuracy = Math.min(100, Math.max(75, rankAccuracy));
                    routingEfficiency = Math.min(100, Math.max(70, routingEfficiency));
                } else {
                    // Default values if no data available
                    blendingScore = 88.5;
                    rankAccuracy = 92.0;
                    routingEfficiency = 90.5;
                }
                
                // Update the metrics display
                document.getElementById('blending-percentage').textContent = blendingScore.toFixed(1) + '%';
                document.getElementById('rank-accuracy').textContent = rankAccuracy.toFixed(1) + '%';
                document.getElementById('routing-efficiency').textContent = routingEfficiency.toFixed(1) + '%';
                
                // Update model usage chart with real model data
                setupModelUsageChart(modelInfo);
            }
        }
        
        // Make an element draggable
        function makeDraggable(element, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            if (handle) {
                // If a handle is provided, use it
                handle.onmousedown = dragMouseDown;
            } else {
                // Otherwise use the entire element as handle
                element.onmousedown = dragMouseDown;
            }
            
            function dragMouseDown(e) {
                e = e || window.event;
                
                // Don't start dragging if clicked on a button or input
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA' || 
                    e.target.tagName === 'INPUT' || e.target.tagName === 'I') {
                    return;
                }
                
                e.preventDefault();
                
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Store the element's current position
                const rect = element.getBoundingClientRect();
                const rightOffset = window.innerWidth - rect.right;
                const bottomOffset = window.innerHeight - rect.bottom;
                
                // Update CSS to use all positions so we can maintain the correct layout
                // during and after dragging
                element.style.right = `${rightOffset}px`;
                element.style.bottom = `${bottomOffset}px`;
                element.style.left = 'auto';
                element.style.top = 'auto';
                
                // Add dragging class
                element.classList.add('dragging');
                
                // Stop animations during drag
                element.style.transition = 'none';
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Get current positions
                const rect = element.getBoundingClientRect();
                let rightOffset = parseInt(element.style.right) + pos1;
                let bottomOffset = parseInt(element.style.bottom) + pos2;
                
                // Ensure the element stays within the viewport
                if (rightOffset < 0) rightOffset = 0;
                if (bottomOffset < 0) bottomOffset = 0;
                if (rightOffset > window.innerWidth - 100) rightOffset = window.innerWidth - 100;
                if (bottomOffset > window.innerHeight - 100) bottomOffset = window.innerHeight - 100;
                
                // Set the element's new position
                element.style.right = `${rightOffset}px`;
                element.style.bottom = `${bottomOffset}px`;
            }
            
            function closeDragElement() {
                // Stop moving when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                
                // Remove dragging class
                element.classList.remove('dragging');
                
                // Restore animations
                element.style.transition = '';
            }
        }
        
        // Setup model usage chart with enhanced model data
        function setupModelUsageChart(modelInfo) {
            const chartElement = document.getElementById('model-usage-chart');
            if (!chartElement) return;
            
            // Model color mapping
            const modelColors = {
                'gpt-4': '#19c37d',
                'gpt-4-turbo': '#19c37d',
                'gpt-3.5-turbo': '#74aa9c',
                'claude-3': '#9c5ddb',
                'claude-2': '#8e44ad',
                'claude-instant': '#a55eea',
                'gemini-pro': '#4285f4',
                'gemini': '#4285f4',
                'mistral': '#00a3bf',
                'mistral-medium': '#00a3bf',
                'mistral-large': '#007285',
                'llama-3': '#f97316',
                'deepseek': '#0ea5e9'
            };
            
            // Default model distribution if no model info is available
            let modelDistribution = {};
            
            if (modelInfo) {
                // Extract model distribution from enhanced response structure
                if (modelInfo.blending_info && modelInfo.blending_info.model_weights) {
                    // Use precise model weights from blending info
                    modelDistribution = modelInfo.blending_info.model_weights;
                } else if (modelInfo.model_contributions) {
                    // Use model contributions if available
                    modelDistribution = modelInfo.model_contributions;
                } else if (modelInfo.ranked_responses && modelInfo.ranked_responses.length > 0) {
                    // Calculate distribution based on ranking scores
                    const rankings = modelInfo.rankings;
                    const totalScore = rankings ? rankings.reduce((sum, item) => sum + (item.score || 0), 0) : 0;
                    
                    if (totalScore > 0) {
                        rankings.forEach(item => {
                            const percentage = ((item.score || 0) / totalScore) * 100;
                            if (percentage > 0) {
                                modelDistribution[item.model] = percentage;
                            }
                        });
                    }
                } else if (modelInfo.models_used && modelInfo.models_used.length > 0) {
                    // Estimate distribution based on models used list
                    // Use the contribution percentages directly from models_used
                    modelInfo.models_used.forEach(model => {
                        modelDistribution[model.name] = model.contribution;
                    });
                } else if (modelInfo.best_model) {
                    // If only the best model is available, assign 100% to it
                    modelDistribution[modelInfo.primary_model] = 100;
                } else {
                    // Default distribution if no useful model info is present
                    modelDistribution = {
                        'gpt-4': 55,
                        'claude-3': 45,
                        'gemini-pro': 30,
                        'mistral-large': 25
                    };
                }
            } else {
                // Default distribution if modelInfo is completely missing
                modelDistribution = {
                    'gpt-4': 55,
                    'claude-3': 45,
                    'gemini-pro': 30,
                    'mistral-large': 25
                };
            }
            
            // Sort models by their contribution percentage (descending)
            const sortedModels = Object.entries(modelDistribution)
                .sort((a, b) => b[1] - a[1]);
            
            // Generate the chart HTML
            let chartHtml = '<div class="simple-chart">';
            
            // Add bars for each model with a contribution
            sortedModels.forEach(([model, percentage]) => {
                // Get appropriate color, or use a default if the model is not in our color mapping
                const color = modelColors[model.toLowerCase()] || '#64748b';
                
                // Create a clean display name by removing version numbers if needed
                let displayName = model;
                if (model.includes('-')) {
                    const baseName = model.split('-')[0];
                    displayName = baseName.charAt(0).toUpperCase() + baseName.slice(1);
                }
                
                // Create the bar with appropriate width and styling
                chartHtml += `
                    <div class="chart-bar" style="width: ${Math.min(100, Math.max(20, percentage))}%; background-color: ${color};" 
                         title="${model}: ${percentage.toFixed(1)}%">${displayName}</div>
                `;
            });
            
            chartHtml += '</div>';
            chartElement.innerHTML = chartHtml;
        }
    // Initialize zoom functionality for the space background
    function initZoomControls() {
        const universeContainer = document.getElementById('universe-container');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomLevelDisplay = document.getElementById('zoom-level');
        const minervaPlaceholder = document.getElementById('minerva-planet');
        
        // Start at normal view (1x) and allow zooming up to x10
        let currentZoom = 1;
        const minZoom = 1;
        const maxZoom = 10;
        const zoomStep = 0.5;
        
        // Initial position - centered
        let posX = 0;
        let posY = 0;
        
        // Make Minerva planet clickable
        if (minervaPlaceholder) {
            minervaPlaceholder.style.cursor = 'pointer';
            minervaPlaceholder.title = 'Click to enter Minerva Control Center';
            minervaPlaceholder.addEventListener('click', function() {
                window.location.href = 'minerva_central.html'; // Navigate to control center
            });
        }
        
        // Update transform
        function updateTransform() {
            universeContainer.style.transform = `translate(${posX}px, ${posY}px) scale(${currentZoom})`;
            zoomLevelDisplay.textContent = `${currentZoom}x`;
        }
        
        // Apply initial zoom immediately
        updateTransform();
        
        // Zoom in button
        zoomInBtn.addEventListener('click', () => {
            if (currentZoom < maxZoom) {
                currentZoom += zoomStep;
                updateTransform();
            }
        });
        
        // Zoom out button
        zoomOutBtn.addEventListener('click', () => {
            if (currentZoom > minZoom) {
                currentZoom -= zoomStep;
                updateTransform();
            }
        });
        
        // Pan functionality with mouse drag
        let isDragging = false;
        let startX, startY;
        let startPosX, startPosY;
        
        universeContainer.addEventListener('mousedown', (e) => {
            // Only start dragging if not clicking on planet or other interactive elements
            if (e.target === universeContainer || 
                e.target.classList.contains('space-background') || 
                e.target.classList.contains('stars-layer') ||
                e.target.classList.contains('nebula')) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startPosX = posX;
                startPosY = posY;
                universeContainer.style.cursor = 'grabbing';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                posX = startPosX + dx;
                posY = startPosY + dy;
                updateTransform();
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                universeContainer.style.cursor = 'grab';
            }
        });
        
        // Double click to reset zoom and position
        universeContainer.addEventListener('dblclick', (e) => {
            // Don't reset if double-clicking on interactive elements
            if (e.target === universeContainer || 
                e.target.classList.contains('space-background') || 
                e.target.classList.contains('stars-layer') ||
                e.target.classList.contains('nebula')) {
                currentZoom = 1;
                posX = 0;
                posY = 0;
                updateTransform();
            }
        });
        
        // Mouse wheel zoom
        universeContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // Calculate zoom center point (relative to current viewport)
            const rect = universeContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate zoom point in the transformed space
            const zoompointX = (mouseX - posX) / currentZoom;
            const zoompointY = (mouseY - posY) / currentZoom;
            
            // Apply zoom based on wheel direction
            if (e.deltaY < 0 && currentZoom < maxZoom) { // Zoom in
                currentZoom = Math.min(currentZoom + zoomStep, maxZoom);
            } else if (e.deltaY > 0 && currentZoom > minZoom) { // Zoom out
                currentZoom = Math.max(currentZoom - zoomStep, minZoom);
            }
            
            // Adjust position to maintain mouse point at the same position
            posX = mouseX - zoompointX * currentZoom;
            posY = mouseY - zoompointY * currentZoom;
            
            updateTransform();
        }, { passive: false });
        
        // Set initial cursor style
        universeContainer.style.cursor = 'grab';
        
        // Touch support for mobile
        let touchStartX, touchStartY;
        let lastTouchDistance = 0;
        
        universeContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                // Single touch for panning
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                startPosX = posX;
                startPosY = posY;
            } else if (e.touches.length === 2) {
                // Two-finger touch for zooming
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
            }
        });
        
        universeContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Pan with single touch
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                posX = startPosX + dx;
                posY = startPosY + dy;
                updateTransform();
            } else if (e.touches.length === 2) {
                // Zoom with pinch gesture
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (lastTouchDistance > 0) {
                    const delta = currentDistance - lastTouchDistance;
                    const zoomDelta = delta * 0.01;
                    
                    // Calculate center of pinch
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    
                    // Get position in transformed space
                    const rect = universeContainer.getBoundingClientRect();
                    const pinchCenterX = (centerX - rect.left - posX) / currentZoom;
                    const pinchCenterY = (centerY - rect.top - posY) / currentZoom;
                    
                    // Apply zoom
                    const newZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + zoomDelta));
                    
                    if (newZoom !== currentZoom) {
                        // Adjust position to maintain pinch center
                        posX = centerX - rect.left - pinchCenterX * newZoom;
                        posY = centerY - rect.top - pinchCenterY * newZoom;
                        currentZoom = newZoom;
                        updateTransform();
                    }
                }
                
                lastTouchDistance = currentDistance;
            }
        }, { passive: false });
        
        universeContainer.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
            }
        });
    }
    
    // Think Tank API error handler
    function handleThinkTankError(error) {
        console.error('Error communicating with Think Tank API:', error);
        return {
            response: 'An error occurred while connecting to the Think Tank. Please try again later.',
            model_info: {
                primary_model: 'System',
                models_used: [{ name: 'System', contribution: 100, color: '#DC2626' }]
            },
            status: 'error',
            error_details: error.message || 'Unknown error'
        };
    }
    
    // Initialize the Minerva Orb functionality
    function initMinervaOrb() {
        const minervaOrb = document.getElementById('minerva-orb');
        const projectOrbsContainer = document.getElementById('project-orbs-container');
        const projectButton = document.getElementById('project-button');
        
        if (minervaOrb) {
            // Click handler for the central Minerva Orb
            minervaOrb.addEventListener('click', () => {
                // Toggle project orbs visibility
                projectOrbsContainer.style.display = projectOrbsContainer.style.display === 'none' ? 'block' : 'none';
                
                if (projectOrbsContainer.style.display === 'block') {
                    projectOrbsContainer.classList.add('active');
                    loadProjectOrbs();
                } else {
                    projectOrbsContainer.classList.remove('active');
                }
            });
            
            // Animation for orb
            minervaOrb.addEventListener('mouseover', () => {
                minervaOrb.style.transform = 'translate(-50%, -50%) scale(1.1)';
            });
            
            minervaOrb.addEventListener('mouseout', () => {
                minervaOrb.style.transform = 'translate(-50%, -50%) scale(1)';
            });
        }
        
        // Project button in chat interface header
        if (projectButton) {
            projectButton.addEventListener('click', () => {
                // Navigate to projects page
                window.location.href = '/projects';
            });
        }
    }
    
    // Function to load project orbs from the project system
    async function loadProjectOrbs() {
        const projectOrbsContainer = document.getElementById('project-orbs-container');
        
        try {
            // Clean previous orbs
            projectOrbsContainer.innerHTML = '';
            
            // Add default general chat orb
            const generalOrb = createProjectOrb('General Chat', null, 0);
            projectOrbsContainer.appendChild(generalOrb);
            
            // Fetch projects from API
            const response = await fetch('/api/projects');
            const data = await response.json();
            
            if (data.status === 'success' && data.projects && data.projects.length > 0) {
                // Sort projects by recency
                const projects = data.projects.sort((a, b) => {
                    return new Date(b.updated_at) - new Date(a.updated_at);
                });
                
                // Add up to 5 most recent projects
                const maxProjects = Math.min(5, projects.length);
                for (let i = 0; i < maxProjects; i++) {
                    const project = projects[i];
                    const projectOrb = createProjectOrb(project.name, project.project_id, i + 1);
                    projectOrbsContainer.appendChild(projectOrb);
                }
            }
        } catch (error) {
            console.error('Error loading project orbs:', error);
            
            // Add fallback orbs if API fails
            const fallbackOrb = createProjectOrb('My First Project', 'fallback-1', 1);
            projectOrbsContainer.appendChild(fallbackOrb);
        }
    }
    
    // Function to create a project orb element
    function createProjectOrb(name, projectId, index) {
        const orb = document.createElement('div');
        orb.className = 'project-orb';
        orb.textContent = name;
        
        // Calculate position in a circle around the center
        const radius = 150; // Distance from center
        const angle = (index / 6) * Math.PI * 2; // Distribute evenly in a circle
        const left = 200 + radius * Math.cos(angle) - 40; // Center of container is 200,200
        const top = 200 + radius * Math.sin(angle) - 40;
        
        orb.style.left = `${left}px`;
        orb.style.top = `${top}px`;
        
        // Add animation delay based on index
        orb.style.transitionDelay = `${index * 0.1}s`;
        
        // Add click handler
        orb.addEventListener('click', () => {
            if (projectId) {
                // If it's a specific project, navigate to project chat
                window.location.href = `/projects#${projectId}`;
            } else {
                // If it's the general chat, just hide the orbs
                document.getElementById('project-orbs-container').style.display = 'none';
                document.getElementById('project-orbs-container').classList.remove('active');
            }
        });
        
        return orb;
    }
    
    // Function to initialize smart suggestions
    function initSmartSuggestions() {
        const suggestionsContainer = document.getElementById('smart-suggestions');
        const chatInput = document.getElementById('chat-input');
        
        if (suggestionsContainer && chatInput) {
            // Show suggestions when input is focused
            chatInput.addEventListener('focus', () => {
                generateSmartSuggestions();
                suggestionsContainer.classList.add('active');
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!chatInput.contains(e.target) && 
                    !suggestionsContainer.contains(e.target) && 
                    !e.target.classList.contains('suggestion-chip')) {
                    suggestionsContainer.classList.remove('active');
                }
            });
        }
    }
    
    // Function to generate contextual smart suggestions
    function generateSmartSuggestions() {
        const suggestionsContainer = document.getElementById('smart-suggestions');
        
        if (suggestionsContainer) {
            // Clear previous suggestions
            suggestionsContainer.innerHTML = '';
            
            // Get message count to contextually adjust suggestions
            const messageCount = document.querySelectorAll('.user-message').length;
            
            // Define suggestion pools based on conversation stage
            let suggestions;
            
            if (messageCount === 0) {
                // First-time suggestions
                suggestions = [
                    "Tell me about yourself",
                    "What can you help me with?",
                    "Start a new project",
                    "Analyze my recent conversations"
                ];
            } else if (messageCount <= 2) {
                // Early conversation suggestions
                suggestions = [
                    "Show me my active projects",
                    "Tell me more about your capabilities",
                    "Help me organize my thoughts",
                    "Can you remember our previous chat?"
                ];
            } else {
                // Deeper conversation suggestions
                suggestions = [
                    "Summarize our conversation",
                    "Save this as a new project",
                    "Can you elaborate more?",
                    "Help me explore this topic deeper"
                ];
            }
            
            // Create suggestion chips
            suggestions.forEach(text => {
                const chip = document.createElement('div');
                chip.className = 'suggestion-chip';
                chip.textContent = text;
                
                // Clicking a suggestion adds it to the input
                chip.addEventListener('click', () => {
                    const chatInput = document.getElementById('chat-input');
                    chatInput.value = text;
                    chatInput.focus();
                });
                
                suggestionsContainer.appendChild(chip);
            });
        }
    }
    
    /**
     * Global function to send messages to the Think Tank API
     * This is the main integration point for the enhanced chat UI
     */
    window.sendToChatAPI = function(message, contextData = {}) {
        console.log('Sending message to Think Tank API:', message, contextData);
        
        // Use existing send message function if available
        if (typeof sendMessageToAPI === 'function') {
            console.log('Using existing sendMessageToAPI function');
            sendMessageToAPI(message);
            return;
        }
        
        // Add user message to chat
        addUserMessage(message);
        
        // Prepare payload for the API
        const payload = {
            message: message,
            session_id: sessionId || 'session-' + Date.now(),
            user_id: userId || 'user-' + Date.now(),
            store_in_memory: true,
            include_model_info: true
        };
        
        // Add conversation ID if available to maintain memory
        if (contextData.conversation_id) {
            payload.conversation_id = contextData.conversation_id;
            console.log('Using existing conversation ID:', payload.conversation_id);
        } else if (localStorage.getItem('minerva_conversation_id')) {
            payload.conversation_id = localStorage.getItem('minerva_conversation_id');
            console.log('Using stored conversation ID:', payload.conversation_id);
        }
        
        // Add any project context
        if (contextData.projectId) {
            payload.project_id = contextData.projectId;
            payload.project_name = contextData.projectName || 'Unknown Project';
        }
        
        // Show typing indicator
        const chatMessages = document.getElementById('chat-messages');
        const loadingId = 'loading-' + Date.now();
        
        // Create loading message
        const loadingElement = document.createElement('div');
        loadingElement.id = loadingId;
        loadingElement.className = 'message ai-message loading';
        loadingElement.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
        chatMessages.appendChild(loadingElement);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Send to API
        fetch('/api/think-tank', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Remove loading indicator
            const loadingElement = document.getElementById(loadingId);
            if (loadingElement && chatMessages.contains(loadingElement)) {
                chatMessages.removeChild(loadingElement);
            }
            
            // Store conversation ID for memory persistence
            if (data.conversation_id) {
                localStorage.setItem('minerva_conversation_id', data.conversation_id);
                console.log(`Conversation ID saved: ${data.conversation_id}`);
                
                // Update any active MinervaChat instances
                if (window.MinervaChat && window.MinervaChat.updateConversationId) {
                    window.MinervaChat.updateConversationId(data.conversation_id);
                }
            }
            
            // Extract model info
            let modelInfo = [];
            try {
                if (data.model_info) {
                    if (data.model_info.models_used) {
                        if (Array.isArray(data.model_info.models_used)) {
                            modelInfo = data.model_info.models_used;
                        } else if (typeof data.model_info.models_used === 'object') {
                            modelInfo = data.model_info.models_used.map(model => model.name);
                            console.log('Extracted model names:', modelInfo);
                        }
                    } else if (data.model_info.primary_model) {
                        modelInfo = [data.model_info.primary_model];
                    } else if (data.model_info.rankings && Array.isArray(data.model_info.rankings)) {
                        modelInfo = data.model_info.rankings.map(item => item.model);
                    }
                }
            } catch (err) {
                console.error('Error extracting model info:', err);
            }
            
            // Default model info if none available
            if (!modelInfo || modelInfo.length === 0) {
                modelInfo = ['Think Tank'];
            }
            
            // Add AI message to chat
            addAIMessage(data.response, modelInfo);
        })
        .catch(error => {
            console.error('Error fetching AI response:', error);
            
            // Remove loading indicator
            const loadingElement = document.getElementById(loadingId);
            if (loadingElement && chatMessages.contains(loadingElement)) {
                chatMessages.removeChild(loadingElement);
            }
            
            // Add error message
            addAIMessage('I apologize, but I encountered an error processing your request. Please try again.', ['System']);
        });
    };
    
    // Initialize all components
    /**
     * Add a user message to the chat
     */
    function addUserMessage(message) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = 'message user-message';
        messageElement.innerHTML = `
            <div class="message-content">${formatMessage(message)}</div>
        `;
        
        // Add to chat
        chatMessages.appendChild(messageElement);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    /**
     * Add an AI message to the chat
     */
    function addAIMessage(message, modelInfo = ['Think Tank']) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = 'message ai-message';
        
        // Format model info
        let modelDisplay = '';
        if (modelInfo && modelInfo.length > 0) {
            modelDisplay = `<div class="model-info">${modelInfo.join(', ')}</div>`;
        }
        
        // Format message content with markdown
        messageElement.innerHTML = `
            ${modelDisplay}
            <div class="message-content">${formatMessage(message)}</div>
        `;
        
        // Add to chat
        chatMessages.appendChild(messageElement);
        
        // Scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    /**
     * Format message with markdown
     */
    function formatMessage(message) {
        if (!message) return '';
        
        // Basic markdown formatting
        // Code blocks
        message = message.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
        
        // Inline code
        message = message.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // Bold
        message = message.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        
        // Italic
        message = message.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        
        // Lists
        message = message.replace(/^- (.+)$/gm, '<li>$1</li>');
        message = message.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
        
        // Line breaks
        message = message.replace(/\n/g, '<br>');
        
        return message;
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log(`Minerva Space initialized at ${new Date().toLocaleTimeString()}`);        
        // Initialize the chat interface
        initChatInterface();
        
        // Make the chat interface draggable
        const chatInterface = document.getElementById('chat-interface');
        const chatHeader = document.getElementById('chat-header');
        makeDraggable(chatInterface, chatHeader);
        
        // Initialize the floating chat for the homepage
        initializeFloatingChat();
        
        // Check for project context
        initializeProjectChat();
        
        // Initialize zoom controls
        initZoomControls();
        
        // Load previous conversation ID if available
        const savedConversationId = localStorage.getItem('minerva_conversation_id');
        if (savedConversationId) {
            console.log('Found saved conversation ID:', savedConversationId);
        }
        
        // Initialize Minerva Orb and project system
        initMinervaOrb();
        
        /**
         * Initialize floating chat feature for homepage
         */
        function initializeFloatingChat() {
            // Only initialize on homepage or if no project context
            const projectContext = document.querySelector('.project-context');
            if (projectContext) return; // We're on a project page
            
            console.log('Initializing floating chat for homepage');
            
            // Create container for floating chat
            const floatingChatContainer = document.createElement('div');
            floatingChatContainer.id = 'floating-chat-container';
            document.body.appendChild(floatingChatContainer);
            
            // Initialize MinervaChat instance
            const floatingChat = new MinervaChat({
                container: floatingChatContainer,
                mode: 'floating',
                persistence: true,
                context: {}
            });
            
            // Store in global scope for access
            window.floatingChat = floatingChat;
        }
        
        /**
         * Initialize project-specific chat
         */
        function initializeProjectChat() {
            // Only initialize on project pages
            const projectContext = document.querySelector('.project-context');
            if (!projectContext) return; // Not on a project page
            
            // Get project ID and name
            const projectId = projectContext.dataset.projectId;
            const projectName = projectContext.dataset.projectName || 'Unnamed Project';
            
            console.log(`Initializing project chat for project ${projectId}: ${projectName}`);
            
            // Find or create container for project chat
            let projectChatContainer = document.getElementById('project-chat-container');
            if (!projectChatContainer) {
                projectChatContainer = document.createElement('div');
                projectChatContainer.id = 'project-chat-container';
                projectChatContainer.className = 'project-chat-panel';
                
                // Find a good place to insert it
                const contentArea = document.querySelector('.content-area') || document.body;
                contentArea.appendChild(projectChatContainer);
            }
            
            // Initialize MinervaChat instance with project context
            const projectChat = new MinervaChat({
                container: projectChatContainer,
                mode: 'project',
                persistence: true,
                context: {
                    projectId: projectId,
                    projectName: projectName
                }
            });
            
            // Store in global scope for access
            window.projectChat = projectChat;
        }
        
        // Initialize smart suggestions
        initSmartSuggestions();
        
        // Initialize the enhanced Minerva Chat Integration
        if (window.MinervaChat) {
            console.log('Initializing Minerva Chat Integration');
            
            // Initialize the floating chat for the homepage
            window.MinervaChat.initFloatingChat({
                position: 'bottom-right',
                initialMessage: 'Welcome to Minerva! How can I assist you today?',
                apiEndpoint: '/api/think-tank',
                preserveMemory: true
            });
            
            // Listen for project context changes
            document.addEventListener('minerva-project-selected', function(e) {
                const projectId = e.detail.projectId;
                const projectName = e.detail.projectName;
                
                console.log(`Project context changed: ${projectName} (${projectId})`);
                
                // Update chat context with project information
                window.MinervaChat.setProjectContext(projectId, projectName);
            });
            
            // Enable project creation from conversations
            window.MinervaChat.enableProjectConversion({
                apiEndpoint: '/api/projects/create-from-conversation',
                onSuccess: function(projectId, projectName) {
                    console.log(`Created project ${projectName} (${projectId}) from conversation`);
                    // Trigger a refresh of project orbs
                    loadProjectOrbs();
                }
            });
        } else {
            console.error('Minerva Chat Integration not loaded!');
        }
        
        console.log('Minerva Space initialized with improved chat interface');
    });
    </script>
</body>
</html>
